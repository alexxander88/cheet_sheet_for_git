# Работа с командной строкой


## Навигация


- `pwd` - (от англ. print working directory, «показать рабочую папку») — покажи, в какой я папке;  
- `ls` (от англ. list directory contents, «отобразить содержимое директории») — покажи файлы и папки в текущей папке;  
- `ls -a` — покажи также скрытые файлы и папки, названия которых начинаются с символа .;  
- `cd first-project` (от англ. change directory, «сменить директорию») — перейди в папку first-project;  
- `cd first-project/html` — перейди в папку html, которая находится в папке first-project;  
- `cd ..` — перейди на уровень выше, в родительскую папку;  
- `cd ~` — перейди в домашнюю директорию (/Users/Username);  
- `cd /` — перейди в корневую директорию.  


## Работа с файлами и папками


### Создание


- `touch index.html` (англ. touch, «коснуться») — создай файл index.html в текущей папке;  
- `touch index.html style.css script.js` — если нужно создать сразу несколько файлов, можно напечатать их имена в одну строку через пробел;  
- `mkdir second-project` (от англ. make directory, «создать директорию») — создай папку с именем second-project в текущей папке.  


### Копирование и перемещение  


- `cp file.txt ~/my-dir` (от англ. copy, «копировать») — скопируй файл в другое место;  
- `mv file.txt ~/my-dir` (от англ. move, «переместить») — перемести файл или папку в другое место.  


### Чтение


- `cat file.txt` (от англ. concatenate and print, «объединить и распечатать») — распечатай содержимое текстового файла file.txt.  


### Удаление


- `rm about.html` (от англ. remove, «удалить») — удали файл about.html;  
- `rmdir images` (от англ. remove directory, «удалить директорию») — удали папку images;  
- `rm -r second-project` (от англ. remove, «удалить» + recursive, «рекурсивный») — удали папку second-project и всё, что она содержит.  


## Полезные возможности


- Команды необязательно печатать и выполнять по очереди. Можно указать их списком — разделить двумя амперсандами (&&).  
- У консоли есть собственная память — буфер с несколькими последними командами. По ним можно перемещаться с помощью клавиш со стрелками вверх (↑) и вниз (↓).  
- Чтобы не вводить название файла или папки полностью, можно набрать первые символы имени и дважды нажать Tab. Если файл или папка есть в текущей директории, командная строка допишет путь сама. Например, вы находитесь в папке dev. Начните вводить cd first и дважды нажмите Tab. Если папка first-project есть внутри dev, командная строка автоматически подставит её имя. Останется только нажать Enter.  


# Работа с репозиториями


- `git init` - сделать папку репозиторием  
- `rm -rf .git` - «разгитить» папку, если что-то пошло не так  
- `git status` - проверить состояние репозитория. Команда всегда подскажет, что происходит с файлом: например, он добавлен в список «на коммит» или ещё вообще не отслеживается, или изменён.  
- `git add` - подготовить файл к сохранению  
- `git add --all` - подготовит к сохранению сразу все файлы  
- `git add .` - можно добавить в репозиторий текущую папку со всеми файлами  
- `git commit -m` - сделать коммит c ключом -m (от англ. message — «сообщение»), который присваивает коммиту сообщение.Оно пишется после ключа -m в кавычках.  
- `git commit --amend --no-edit` - дополнить коммит новыми файлами. Благодаря опции --no-edit сообщение к коммиту останется таким, каким и было.  
- `git commit --amend -m "Обновлённое сообщение коммита"` - изменить сообщение к коммиту позволяет команда. --amend рассчитан на работу с последним коммитом (HEAD).  
- `git log` - просмотреть историю коммитов  
- `git log --oneline` - получить сокращённый лог. В сокращённом логе выводятся сокращённые хеши — их можно использовать точно так же, как и полные.  
- `git remote add origin git@github.com:%ИМЯ_АККАУНТА%/first-project.git` - привязать удалённый репозиторий к локальному
- `git remote -v` - убедиться, что репозитории связаны  
- `git push` - отправить изменения на удалённый репозиторий.  
- `git push -u origin main` - В первый раз эту команду нужно вызвать с флагом -u и параметрами origin (имя удалённого репозитория) и main или master (название текущей ветки). Флаг -u свяжет локальную ветку с одноимённой удалённой.  
- `git diff` - сравнит последнюю закоммиченную версию файла с той, что находится в состоянии modified.  
- `git diff --staged` - покажет изменения в staged-файлах относительно последних закоммиченных версий.  
- `git diff <коммит1> <коммит2>` - c её помощью удобно сравнивать изменения в двух коммитах.  
- `git clone` - копирует проект на локальный компьютер и автоматически связывает локальный репозиторий с удалённым.  

## Игнорирование файлов

 - Если нужно, чтобы Git игнорировал какие-то файлы, стоит составить файл `.gitignore`.  
 - `git status --ignored` - посмотреть, что игнорируется.  
 - Сам файл `.gitignore` — это обычный файл в репозитории. Его тоже стоит закоммитить.  
 - Шаблонов много, но их легко найти в интернете вместе с примерами использования.  

## Откатиться назад

- `git restore --staged <file>` - переведёт файл из staged обратно в modified или untracked.  
- `git reset --hard <commit hash>` - «откатит» историю до коммита с хешем <hash>. Более поздние коммиты потеряются!  
- `git restore <file>` -  «откатит» изменения в файле до последней сохранённой (в коммите или в staging) версии.  

## Ветки  

- Ветка — это последовательность независимых изменений.  
- Благодаря веткам несколько человек могут работать над одним репозиторием и не мешать друг другу. А ещё ветки помогают декомпозировать большую и страшную задачу на маленькие и понятные.  
- Основная версия проекта хранится в главной ветке `main` (или `master`). 
- Разные ветки в одном проекте существуют независимо. Изменения в одной не влияют на изменения в другой.  
- Ветка указывает на коммит, который сделан в ней последним. При этом две ветки могут ссылаться на один и тот же коммит — например, если вы только что создали ветку, но ещё не успели внести в неё коммит.  
- С помощью команды `git branch` можно посмотреть, какие в проекте есть ветки и в какой из них вы сейчас находитесь.  
- `git branch <название_ветки>` - создать ветку.  
- `git checkout <название_ветки>` - переключиться на другую ветку.  
- `git checkout -b <название_ветки>` - создать ветку и сразу же перейти в неё
- `git diff` может сравнивать ветки по их названиям. Например, команда `git diff master feature/my-feature` выведет разницу между основной веткой и веткой `feature/my-feature`.  
- Git поддерживает суффикс навигации `~`. С его помощью можно сослаться на предыдущие коммиты. Например, если вы находитесь в ветке `master` и хотите вывести разницу между тем коммитом, который был три коммита назад, и текущим, нужно выполнить `git diff master~3 master`.  
- Выполнить слияние веток позволяет команда `git merge <название_ветки>`. В качестве параметра указывают название ветки, которую нужно влить в текущую.  
- Удалять ненужные ветки после слияния — хорошая практика. Так в вашем репозитории всегда будет порядок. За удаление веток отвечает команда `git branch -D <название_ветки>` и её щадящий вариант с флагом `-d`.  

# Хеширование коммитов

- Git преобразует информацию о коммитах с помощью алгоритма SHA-1 и для каждого из них рассчитывает уникальный идентификатор — хеш.  
- Хеш — основной идентификатор коммита и позволяет узнать его автора, дату и содержимое закоммиченных файлов.  
- Все хеши, а также таблицу соответствий хеш → информация о коммите Git хранит в папке .git.  

# Статусы файлов в Git

- Статусом untracked помечается файл, о существовании которого Git знает, но не следит за изменениями в нём. Этот статус — противоположность tracked, в который попадают все файлы, отслеживаемые Git.  
- Файл переходит в статус staged после выполнения git add.  
- Статус modified означает, что файл был изменён.  
- Большинство файлов в проектах «шагает» по следующему циклу: «изменён» → «добавлен в список на коммит» → «закоммичен» → «изменён» → и так далее.  

# Командная работа в Git  

## Feature branch workflow  

Самый популярный подход к работе с Git в команде — это feature branch workflow. В нём создают ветку для каждой задачи (например, для новой функциональности или исправления бага), а когда всё готово, вливают новую ветку в `main`.  

Важные этапы этого процесса — пул-реквест и ревью изменений. Пул-реквест — это интерфейс, в котором можно обсудить изменения. Ревью — просмотр изменений другими участниками и один из способов проверить качество таких изменений.  

Если вы уже участник проекта (или collaborator в терминах GitHub), можно клонировать репозиторий напрямую. А если нет, нужно предварительно сделать «форк». Также для участников доступна кнопка __Merge__ после ревью, а для неучастников — нет.  

## Конфликты слияния  

Когда один и тот же файл меняется в нескольких ветках, при их слиянии может произойти конфликт. Пугаться конфликтов не нужно, это нормальная часть работы с системами контроля версий. IDE, вроде VSCode или Intellij IDEA, помогут «склеить» файл из двух конфликтующих версий.  

## Алгоритм-шпаргалка для создания PR  

1. Склонировать репозиторий.  
	1.1. Если вы не участник проекта, предварительно сделать «форк» исходного репозитория.  
	1.2. На странице репозитория или «форка» нажать кнопки: __Code__ → __SSH__ → __скопировать__ __ссылку__.  
	1.3. Выполнить команду `git clone <ссылка на репозиторий>`.  
2. Создать ветку для вашей задачи: `git checkout -b my-task-branch-name`.  
3. Добавить и «закоммитить» изменения, которые вы хотите внести в проект.  
4. «Запушить» ветку: `git push --set-upstream origin HEAD` или `git push -u origin my-task-branch-name`.  
	4.1. GitHub (с помощью Git) выведет ссылку на создание PR. По ней нужно перейти.  
	4.2. PR можно также создать через интерфейс GitHub.  
5. Сообщить о пул-реквесте ревьюеру.  
	5.1. Иногда ревьюеры назначаются автоматически, тогда сообщать не нужно.  
6. Обсуждать с ревьюером предлагаемые изменения и вносить правки, пока эти изменения не будут одобрены (пока не будет получен «апрув»).  
	6.1. Если кто-то добавил конфликтующие изменения в `main`, пока ваш PR был на ревью, нужно разрешить конфликт:  
		- Обновить `main`: `git checkout main && git pull`.  
		- Влить `main` в свою ветку: `git checkout my-task-branch-name && git merge main`.  
		- Разрешить конфликты слияния с помощью IDE или вручную.  
		- Создать коммит слияния: `git commit --no-edit или git commit -m 'merge main'`.  
		- Сделать `git push` своей ветки.
7. Нажать кнопку __Merge__ или подождать, пока её нажмёт кто-то ещё.  
8. Ещё раз обновить `main`, чтобы «подтянуть» ваши изменения в основную ветку локального репозитория: `git checkout main && git pull`.  
9. Вы великолепны! Можете начинать снова со второго пункта.  

## Алгоритм-шпаргалка для разрешения конфликтов слияния

1. Открыть проект в IDE (VS Code, IDEA или другие).
2. Открыть файл, в котором есть конфликт.
3. Выбрать, какие части файла нужно взять из одной ветки, а какие — из другой.
4. Когда конфликты разрешены, сделать коммит: `git commit --no-edit` или `git commit -m 'merge branch <название ветки>'`.  